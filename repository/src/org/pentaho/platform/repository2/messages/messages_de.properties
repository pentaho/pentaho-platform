# Copyright 2008 - 2010 Pentaho Corporation.  All rights reserved.
# This program is free software; you can redistribute it and/or modify it under the 
# terms of the GNU General Public License, version 2 as published by the Free Software 
# Foundation.
#
# You should have received a copy of the GNU General Public License along with this 
# program; if not, you can obtain a copy at http://www.gnu.org/licenses/gpl-2.0.html 
# or from the Free Software Foundation, Inc., 
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.

AbstractRepositoryLifecycleManager.ERROR_0001_STARTUP_NOT_CALLED=Starten muss zuerst aufgerufen werden
MondrianRepositoryLifecycleManager.USER_0001_VER_COMMENT_MONDRIAN=[System] Mondrian-Ordner erstellt
PdiRepositoryLifecycleManager.USER_0001_VER_COMMENT_PDI=[System] PDI-Ordner erstellt
PdiRepositoryLifecycleManager.USER_0002_VER_COMMENT_DATABASES=[System] Datenbanken-Ordner erstellt
PdiRepositoryLifecycleManager.USER_0003_VER_COMMENT_SLAVESERVERS=[System] SlaveServers-Ordner erstellt
PdiRepositoryLifecycleManager.USER_0004_CLUSTERSCHEMAS=[System] clusterSchemas-Ordner erstellt
PdiRepositoryLifecycleManager.USER_0005_PARTITIONSCHEMAS=[System] partitionSchemas-Ordner erstellt
PentahoJcrTemplate.ERROR_0001_ACCESS_DENIED=Zugriff auf diese Daten verweigert
DefaultRepositoryLifecycleManager.USER_0001_VER_COMMENT_PENTAHO_ROOT=[System] Pentaho-Stammorder erstellt
DefaultRepositoryLifecycleManager.USER_0002_VER_COMMENT_TENANT_ROOT=[System] Mandantenstammordner erstellt
DefaultRepositoryLifecycleManager.USER_0003_TENANT_PUBLIC=[System] \u00d6ffentlicher Mandantenordner erstellt
DefaultRepositoryLifecycleManager.USER_0004_TENANT_HOME=[System] Mandantenbasisordner erstellt
DefaultRepositoryLifecycleManager.USER_0005_TENANT_ETC=[System] Mandantenordner usw. erstellt
DefaultRepositoryLifecycleManager.USER_0006_USER_HOME=[System] Benutzerbasisordner erstellt
DefaultUnifiedRepositoryWebService.ERROR_0001_NO_IMPL=keine Implementierung von IUnifiedRepository
ExceptionLoggingDecorator.lockException=Fehler beim Sperren von {0}\n\nReferenznummer: {1}
ExceptionLoggingDecorator.transactionException=Transaktionsfehler w\u00e4hrend {0}\n\nReferenznummer: {1}
ExceptionLoggingDecorator.accessDeniedException=Zugriff verweigert, wenn {0}\n\n Referenznummer: {1}
ExceptionLoggingDecorator.referentialIntegrityException=referenzieller Integrit\u00e4tsfehler w\u00e4hrend {0}; (Die Datei {1} wird \u00fcber die Datei(en) {2} referenziert)\n\nReferenznummer: {3}
ExceptionLoggingDecorator.fileExistsException=Fehler "Die Datei besteht bereits" w\u00e4hrend {0}; der Pfad lautet "{1}"\n\nReferenznummer: {2}
ExceptionLoggingDecorator.malformedNameException=Fehler "Name ist falsch formatiert" w\u00e4hrend {0}; ung\u00fcltiger Name: "{1}"\n\nReferenznummer: {2}
ExceptionLoggingDecorator.canUnlockFile=M\u00f6glichkeit zur Entsperrung der Datei mit der ID "{0}" wird ermittelt.
ExceptionLoggingDecorator.createFile=Datei mit dem Namen "{0}" wird erstellt.
ExceptionLoggingDecorator.createFolder=Ordner mit dem Namen "{0}" wird erstellt.
ExceptionLoggingDecorator.deleteFile=Datei mit ID "{0}" wird gel\u00f6scht.
ExceptionLoggingDecorator.deleteFileAtVersion=Datei mit ID "{0}" und Versionskennung "{1}" wird gel\u00f6scht.
ExceptionLoggingDecorator.generalException=Ausnahmefehler w\u00e4hrend {0}\n\nReferenznummer: {1}
ExceptionLoggingDecorator.getAcl=ACL f\u00fcr Datei mit ID "{0}" wird abgerufen.
ExceptionLoggingDecorator.getChildren=Untergeordnete Elemente f\u00fcr Ordner mit ID "{0}" werden abgerufen.
ExceptionLoggingDecorator.getData=Daten f\u00fcr die Datei mit ID "{0}" werden abgerufen.
ExceptionLoggingDecorator.getDataInBatch=Daten werden f\u00fcr die Dateien abgerufen.
ExceptionLoggingDecorator.getDataAtVersion=Daten f\u00fcr die Datei mit ID "{0}" und Versionskennung "{0}" werden abgerufen.
ExceptionLoggingDecorator.getDeletedFiles=Alle gel\u00f6schten Daten werden abgerufen.
ExceptionLoggingDecorator.getDeletedFilesInFolder=Gel\u00f6schte Daten im Ordner mit dem Pfad "{0}" werden abgerufen.
ExceptionLoggingDecorator.getEffectiveAces=G\u00fcltige ACEs f\u00fcr die Datei mit ID "{0}" werden abgerufen.
ExceptionLoggingDecorator.getFile=Datei mit dem Pfad "{0}" wird abgerufen.
ExceptionLoggingDecorator.getReferrers=Verweise f\u00fcr die Datei mit ID "{0}" werden abgerufen.
ExceptionLoggingDecorator.getTree=Die Struktur mit dem Stammpfad "{0}" wird abgerufen.
ExceptionLoggingDecorator.getFileAtVersion=Datei mit ID "{0}" und Versionskennung "{1}" wird abgerufen.
ExceptionLoggingDecorator.getFileById=Datei mit ID "{0}" wird abgerufen.
ExceptionLoggingDecorator.getVersionSummaries=Versionsverlauf f\u00fcr die Datei mit ID "{0}" wird abgerufen.
ExceptionLoggingDecorator.getVersionSummary=Versionsinformationen f\u00fcr die Datei mit ID "{0}" und Versionskennung "{1}" werden abgerufen.
ExceptionLoggingDecorator.getVersionSummaryInBatch=Versionsinformationen f\u00fcr die Dateien werden abgerufen.
ExceptionLoggingDecorator.hasAccess=Zugang zur Datei mit dem Pfad "{0}" wird ermittelt.
ExceptionLoggingDecorator.lockFile=Datei mit ID "{0}" wird gesperrt.
ExceptionLoggingDecorator.moveFile=Datei mit ID "{0}" wird zum Zielpfad "{1}" verschoben.
ExceptionLoggingDecorator.copyFile=Datei mit ID "{0}" wird zum Zielpfad "{1}" kopiert.
ExceptionLoggingDecorator.referenceNumber=Referenznummer: {0}
ExceptionLoggingDecorator.restoreFileAtVersion=Datei mit Datei-ID "{0}" und Versionskennung "{1}" wird wiederhergestellt.
ExceptionLoggingDecorator.undeleteFile=Datei mit ID "{0}" wird wiederhergestellt.
ExceptionLoggingDecorator.unlockFile=Datei mit ID "{0}" wird freigegeben.
ExceptionLoggingDecorator.updateAcl=ACL f\u00fcr Datei mit ID "{0}" wird aktualisiert.
ExceptionLoggingDecorator.updateFile=Datei mit ID "{0}" wird aktualisiert.
ExceptionLoggingDecorator.getReservedChars=Reservierte Zeichen werden abgerufen.
ExceptionLoggingDecorator.getAvailableLocalesForFile=Verf\u00fcgbare Gebietsschemas f\u00fcr Datei "{0}" werden abgerufen.
ExceptionLoggingDecorator.getLocalePropertiesForFile=Gebietsschemaeigenschaften f\u00fcr Datei "{0}" werden abgerufen.
ExceptionLoggingDecorator.setLocalePropertiesForFile=Gebietsschemaeigenschaften f\u00fcr Datei "{0}" werden festgelegt.
ExceptionLoggingDecorator.deleteLocalePropertiesForFile=Gebietsschemaeigenschaften f\u00fcr Datei "{0}" werden gel\u00f6scht.
FileImporter.WARN_0001_NO_EXT={0} wird \u00fcbersprungen, da keine Erweiterung f\u00fcr die Datei besteht.
FileImporter.WARN_0002_NO_CONVERTER={0} wird \u00fcbersprungen, da kein Konverter f\u00fcr die Erweiterung gefunden wurde.
FileImporter.WARN_0003_IOEXCEPTION={0} wird aufgrund einer Ausnahme \u00fcbersprungen.
FileImporter.WARN_0004_NO_MIME={0} \u00fcberspringen, da kein MIME-Typ f\u00fcr die Erweiterung gefunden wurde
FileImporter.USER_0001_IMPORT_COUNT={0} von {1} Dateien importiert ({2} ms)
FileImporter.ERROR_0001_ERROR_RETRIEVING_FILES=Fehler beim Abrufen der Dateien
FileImporter.ERROR_0002_ERROR_IMPORTING_FILE=Fehler beim Importieren der Datei {1}: {0}
JackrabbitRepositoryFileAclDao.ERROR_0001_NODE_NOT_FOUND=Knoten mit der ID [{0}] nicht gefunden
JackrabbitRepositoryFileAclDao.ERROR_0002_POLICY=h\u00f6chstwahrscheinlich, weil readAclById aufgerufen wurde, bevor createAcl aufgerufen wurde
JackrabbitRepositoryFileAclDao.USER_0001_VER_COMMENT_CREATED_ACL=[System] ACL erstellt
JackrabbitRepositoryFileAclDao.USER_0002_VER_COMMENT_UPDATED_ACL=[System] ACL aktualisiert
JcrRepositoryFileDao.ERROR_0001_NO_TRANSFORMER=kein Transformator gefunden
JcrRepositoryFileDao.ERROR_0002_CANNOT_OVERWRITE_FILE_WITH_FOLDER=Datei kann nicht mit Ordner \u00fcberschrieben werden
JcrRepositoryFileDao.ERROR_0003_ILLEGAL_DEST_PATH=unzul\u00e4ssiger Zielpfad
JcrRepositoryFileDao.ERROR_0004_PARENT_MUST_EXIST=Es muss ein direkter \u00fcbergeordneter Ordner des Zielpfads bestehen
JcrRepositoryFileDao.ERROR_0005_PARENT_MUST_BE_FOLDER=Das \u00fcbergeordnete Element des Zielpfads ist kein Ordner
JcrRepositoryFileDao.USER_0001_VER_COMMENT_ADD_FOLDER=[system] hinzugef\u00fcgter untergeordneter Ordner "{0}" zu {1}
JcrRepositoryFileDao.USER_0002_VER_COMMENT_ADD_FILE=[system] hinzugef\u00fcgte untergeordnete Datei "{0}" zu {1}
JcrRepositoryFileDao.USER_0003_VER_COMMENT_LOCK_FILE=[system] gesperrte Datei mit ID={0}
JcrRepositoryFileDao.LOCALE_0001_UPDATE_PROPERTIES=Aktualisieren der Eigenschaften des Gebietsschemas f\u00fcr ID={0}
JcrRepositoryFileDao.LOCALE_0002_DELETE_PROPERTIES=L\u00f6schen der Eigenschaften des Gebietsschemas f\u00fcr ID={0}
JcrRepositoryFileUtils.ERROR_0001_MISSING_EXT=Dateinamen m\u00fcssen eine Erweiterung aufweisen
JcrRepositoryFileUtils.USER_0001_VER_COMMENT_UNLOCK_FILE=[system] freigegebene Datei mit ID={0}
JcrRepositoryFileUtils.WARN_0001_NPE_FROM_CR="NPE von Inhaltsrepository abfragen"
XmlAdapter.ERROR_0001_MARSHAL=Fehler beim Marshalling von {0} nach {1}
XmlAdapter.ERROR_0002_UNMARSHAL=Fehler beim Un-Marshalling von {0} nach {1}
DefaultDeleteHelper.ERROR_0001_PATH_NOT_FOUND=ID des \u00fcbergeordneten Original-Ordners kann nicht bestimmt werden, da der Zielpfad des \u00fcbergeordneten Ordners nicht vorhanden ist
DefaultDeleteHelper.ERROR_0002_NOT_CLEAN=dies sollte \u00fcber "Wiederherstellen" oder "Endg\u00fcltig l\u00f6schen" bereinigt worden sein
JcrRepositoryFileDao.ERROR_0006_ACCESS_DENIED_DELETE=Zugriff verweigert w\u00e4hrend die Datei mit ID [ {0} ] gel\u00f6scht wird
DefaultUnifiedRepository.ERROR_0001_ACCESS_DENIED_UPDATE_ACL=Zugriff verweigert, w\u00e4hrend Berechtigungen f\u00fcr die Datei mit ID [ {0} ] hochgeladen werden
AclNodeHelper.ERROR_0001_ROOT_FOLDER_NOT_AVAILABLE=Stammverzeichnis {0} nicht verf\u00fcgbar. Standard-{1} wird stattdessen verwendet
AclNodeHelper.WARN_0001_REMOVE_ACL_NODE=Entfernen des ACL-Knotens:
AclNodeHelper.WARN_0002_REMOVE_ACL_STORE=Entfernen des ACL-Speichers: {0}
